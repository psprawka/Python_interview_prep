
# Test your advanced knowledge:

# 1. Create a generator with nested loop (two for loops).


# 2. Create a fibonacci generator and stop it after 10 calls in two ways: with passing stop parameter and without passing it.


# 3. Using a list comprehension, create a list from `numbers = [34.6, -203.4, 44.9, 68.3, -12.2, 44.6, 12.7]` that will contain only positive numbers form that list as integers.


# 4. Create a partial function from a function.


# 5. Create a partial function from a built-in method in python (google "built-in methods in python" and choose one you like the most).


# 6. Edit the following function: `def func(u,v,w,x): return u*4 + v*3 + w*2 + x` with partial() call, so the new function takes one parameter and returns 60. Print out the result of new partial function.


# 7. Play around with all code introspection functions.


# 8. Create and call a function that uppercases characters on 10 different type elements in list.


# 9. Use lambda function to raise to the power of 2 each element in the above list with `map()`.


# 10. Pass multiple iterables to `map()` function.


# 11. Recreate `zip()` function with `map()` (lambda is also recommended).


# 12. Calculate the sum of 10 numbers in list with `reduce()`.


# 13. Calculate a chance of winning a lottery (6 out of 49) with `reduce()` function.


# 14. There is a list of floats, all in five decimal places. Return a map object with each element round up to its position decimal places, meaning that you have to round up the first element in the list to one decimal place, the second one to two decimal places etc.


# 15. Make a nested loop and a python closure to make functions to get multiple multiplication functions using closures. That is using closures, one could make functions to create multiply_with_5() or multiply_with_4() functions using closures. (`multiplywith5 = multiplier_of(5)` `multiplywith5(9)`).


# 16. Create a function that takes 3 arguments and prints them. Call it by passing only *args and **kwargs.


# 17. In one function, use all of fargs, *args and **kwargs.


# 18. Create generator, list, dict and set comprehensions.


# 19. Create a function which receives 2 required + a variable amount of arguments and returns the number of extra args.


# 20. Modify a function `def bar(a, b, c):` so it returns true if the argument with a keyword number equals 7.


# 21. Print out all the duplicates from list.


# 22. Create a coroutine. Use `yield` twice and see what it does. Use `fct.send()` before `next()` as see what it does.


# 23. Create a few 2 dimensional arrays, then try to convert them to nested lists by using list comprehension.


# 24. Use `a = ["Jake", "John", "Eric"]` and `b = ["John", "Jill"]`  lists to print out a set containing all the participants from event A which did not attend event B. Play around with those.


# 25. Create two functions that define a mutable iterable (as none and empty, respectively) as a first parameter and the value as another one. It adds a value to an iterable. Call & print it 3 times. Iterable defined as empty should add to iterable each time fct is called, while none should create a new list each time.